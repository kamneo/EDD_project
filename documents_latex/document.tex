\documentclass[12pt]{article}

\usepackage[T1]{fontenc} 
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{url}
\usepackage{color}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{alltt}
\usepackage{tocbibind}


\title{Rapport Final projet EDD}
\author{Pinero, Borde, Bonnet}

\begin{document}
\maketitle
\tableofcontents

\newpage

\section{Le projet}
\subsection{Pr\'esentation}
Le projet ce compose de plusieurs parties de d\'eveloppement sur un sujet
commun, le jeu du 2048. Ce jeu conciste \`a additionner des tuiles de m\^eme
puissance de 2, sur un plateau de 16 tuiles, jusqu'\`a ce que le plateau soit
plien et qu'aucune addition ne soit possible. Le but du jeu et d’arriver \'a
construire une brique de valeur la plus grande possible (2048, 4096,
8192, \ldots)
\par 
\emph{\color{red}POURQUOI PAS AJOUTER UNE PHOTO EXEMPLE ?!}
\subsection{Le sujet}
Dans le projet nous avons eu \`a r\'ealiser dans un premier temps l'ensemble du
moteur du jeu et quelques tests qui nous garantisent un maximum la v\'eracit\'e 
pendant le d\'eveloppement. Dans un deuxi\`eme temps, nous devions faire la
\og critique \fg{} du developpement de la premi\`ere partie faite par
d'autres groupes bas\'e sur une grille d'evaluation qui nous a \'et\'e
fourni. Ensuite nous avons r\'ealiser un ensemble de strat\'egie de jeu qui
sont capable de jouer de mani\`ere autonome une partie enti\`ere, jusqu'\'a la
fin de la partie. Ces strat\'egies doivent \`a chaque tours calculer le meilleur
prochain coups pour atteindre le plus grand score possible. La derni\`ere partie
du projet conciste \`a r\'ealis\'e une v\'eritable interface graphique pour
jouer au jeu.

\newpage
\section{D\'eveloppement du 2048 et tests}
Pour le d\'eveloppement du 2048, le langage de programmation \'etait impos\'e,
nous devions utilis\'e le langage C. Chaque groupe ont d\^u fournir les sources
permettant de g\'en\'erer une biblioth\`eque libgrid.a (impl\'ementant les
fonctions d'\'ecrites dans grid.h en annexe \ref{grid_h}) ainsi qu’un
ex\'ecutable permettant de jouer au 2048 dans la console. En plus de ça, nous
avons r\'ealis\'e des tests pour v\'erifier toutes les fonctions
impl\'ement\'es.\par

Avant de commencer le travail de d\'eveloppement, nous avons utilis\'e un
outil de gestion de versions d\'ecentralis\'e pour que chaque membre du groupe
puisse avoir acc\'es \`a chaque instant \`a la derni\`ere version du projet.
Pour ça nous avons choisit le logiciel \href{http://git-scm.com/}{GIT}, et la plateforme
\href{http://github.com/}{GitHub}. Les sources du projet ont \'et\'e disponible tout
au long du d\'eveloppement \href{http://github.com/kamneo/EDD_project}{ici}.\par

En ce qui concerne l'arborescence de notre projet, nous avons d\'ecid\'e d'avoir
une organisation bien pr\'ecise pour quelle puisse \^etre le plus possible
g\'en\'erique, c'est \'a dire quelle s'adapte aux \'evolutions du projet.
Mais surtout pour quelle soit le plus clair possible.

\begin{alltt}
{\color{gray}
EDD_projet/        # Racine du projet
    bin/           # Fichiers ex\'ecutables.
    build/         # Fichiers de compilation du projet
    include/       # Fichiers .h des librairies g\'en\'er\'es
    lib/           # Libraires
    src/           # Fichiers tous les fichiers sources
        2048/      # Fichiers sources de l'interface graphique
        grid/      # Fichiers du moteur de jeu
            tests/ # Fichiers qui testent le moteur de jeu
}
\end{alltt}

\par

Tout au long du d\'eveloppement du projet, tous les membres du groupe se sont
mis d'accord sur le fait d'utiliser l'outils \href{http://www.cmake.org/}{CMake}
pour compiler le projet, g\'en\'erer les Makefiles qui servent eux-m\^emes \`a g\'en\'erer les
ex\'ecutables, les libraires et ex\'ecuter les tests.

\subsection{Le developpement de grid.c}
En ce qui concerne le d\'eveloppement de grid.c, qui est le moteur du jeu,
c'\'et\'e relativement simple. Les fonctions qui ont m\'erit\'e un r\'eflexion
s\'erieuse sont \og do\_move() \fg{} et \og cam\_move() \fg{}. Pour ces
fonctions nous devions limit\'e au mieux la duplication de code et la compl\'exit\'e de
l'algorithme. Chose que nous n'avions au final pas tr\`es bien reussi, mais nous
veront dans la pratie \ref{notre_etude}.

\subsubsection{Implementation de \og can\_move \fg{}}
Pour cette fonction, nous avons choisi l'algorithme suivant :

\begin{alltt}
{\color{gray}
Si la direction donn\'ee est \og UP \fg{} ou \og DOWN \fg{} alors
    Pour chaque colonne faire :
        Pour chaque tuile de la colonne faire :
            Si la tuille pr\'ec\'edente est \'egale \`a la courante
                retourner vrai
 		
            Si la tuille courante et non vide 
                   et qu'il y a une tuille vide dans la colonne
                retourner vrai	    	
Si la direction donn\'ee est \og RIGHT \fg{} ou \og LEFT \fg{} alors
    Pour chaque ligne faire 
        Pour chaque tuile de la ligne faire
            Si la tuille pr\'ec\'edente est \'egale \`a la courante
                retourner vrai
 		
            Si la tuille courante et non vide alors
                   et qu'il y a une tuille vide dans la ligne
                retourner vrai	    	
retourner faux
}
\end{alltt}

Cette fonction est utilis\'ee \'a plusieurs reprises dans d'autres fonction
comme par exemple \og game\_over \fg{} ou \og do\_move \fg{}. d'o\`u
l'importance qu'elle n'ai pas une trop grande comp\`exit\'e de calcul.

\subsubsection{Implementation de \og do\_move \fg{}}
Pour cette fonction, nous avons choisi l'algorithme suivant :
\begin{alltt}
{\color{gray}
Si la direction donn\'ee ne peut pas \^etre jouer
    Ne rien faire
    
    
Si la direction donn\'e est \og UP \fg{} ou \og DOWN \fg{} alors
    Pour chaque colonne faire :
        Pour chaque tuile de la colonne faire :
            Si la tuille pr\'ec\'edente est \'egale \`a la courante
                On fusionne les deux tuilles
                On modifie le score de la partie
            
            Si la tuille courante est vide alors
            	On change sa place avec la premi\`ere tuille non vide
            	
Si la direction donn\'ee est \og RIGHT \fg{} ou \og LEFT \fg{} alors
    Pour chaque ligne faire 
        Pour chaque tuile de la ligne faire :
            Si la tuille pr\'ec\'edente est \'egale \`a la courante
                On fusionne les deux tuilles
                On modifie le score de la partie
            
            Si la tuille courante est vide alors
            	On change sa place avec la premi\`ere tuille non vide
}
\end{alltt}

\subsection{L'afficage de la grille dans la console}
Pour l'affichage de la grille dans la console, nous avons eu plusieurs version
et design. La toute premi\`ere version \'etait une simple grille dans la console
o\`u \'etait affich\'e le score et les valeurs des tuilles. Dans cette version
nous devions jouer avec les lettres Z, Q, S et D du clavier car dans le language C, la
fonction \og scanf \fg{} de la librairie \og stdio \fg{} qui permet de
lire l'entr\'ee standard, ne prend pas en compte les fl\`eches du clavier.
En annexe vous touverai une capture d'ecran de cette version.\par
Dans une deuxim\`eme version, nous avions d\'ecid\'e de mettre des couleurs dans
les tuilles en fonction de leurs valeurs. (\`a voir en annexe \ref{grille_couleur}).\par
Enfin pour r\'epondre correctement au sujet, nous avons utilis\'e la librairie
\og NCurses \fg{}. L'utilisation de cette librairie nous a permis de se
lib\'erer de deux de nos difficult\'es. La premi\`ere \'etait celle que nous devions jouer
avec des lettres et non les fl\`eches du clavier, la seconde \'etait que nous
n'avions d'affichage dynamique de la grille \`a chaque coup. Pour \^etre plus
clair, lorsqu'on jou\'e un coups avec les deux premi\`eres version de
l'affichage, la grille du coup pr\'ecedent \'etait toujours pr\'esent dans la
console. D\'esormais, la console n'affiche plus qu'une grille et elle met \`a
jour apr\`es chaque coups.

\subsection{Les tests}
Les Tests sont \'ecrit pour confronter une r\'ealisation \`a sa sp\'ecification.
Le test d\'efinit un crit\`ere d’arr\^et (\'etat ou sorties \`a l’issue de
l’ex\'ecution) et permet de statuer sur le succ\`es ou sur l’\'echec d’une
v\'erification. Gr\^ace \`a la sp\'ecification, on est en mesure de faire
correspondre un \'etat d’entr\'ee donn\'e \`a un r\'esultat ou \`a une sortie.
Le test permet de v\'erifier que la relation d’entr\'ee / sortie donn\'ee par la
sp\'ecification est bel et bien r\'ealis\'ee.
\cite{Test_unitaire}

\par Sur ce principe nous avons r\'ealis\'e un test par fonction d\'ecrite dans
le fichier \og grid.h \fg{} et un test sur la r\'ealisation de plusieurs parties
qui s'ex\'ecutent avec une strat\'egie basique qui consiste \`a jouer a gauche
si on le peut sinon \`a droite, sinon en haut enfin en bas. Ainsi lorsqu'on fait
des modifications de l'une de ces fonctions, nous nous assurons que cela n'a en
rien chang\'e \`a la v\'eracit\'e des r\'esultats. L'e\'ecution des tests
s'\'effectue avec la commande \og make test \fg{}. L'utilisation de la
technologie \og CMake \fg{} nous permet d'avoir un affichage complet \`a la fin
des tests sur leurs r\'esultats pour savoir s'ils sont pass\'es avec succ\`es
ou non (exemple en annexe \ref{test}).

\newpage
\section{Relectures critiques}
\`A l’issue de la premi\`ere phase de travail, chaque groupe ont d\^u relire le
code produit par trois autres groupes. Pour chaque groupe \`a relire, on a
rempli un formulaire d’\'ealuation. Ce formulaire d’\'ealuation nous a \'et\'e
fourni par notre charg\'e de TD.

\par Cette feuille d'\'evaluation \'etait compos\'ee de 13 questions orient\'ees
sur trois axes. Le point de vue utilisateur, qui pousse \`a v\'erifier
principalement la propet\'e de l'archive, que la compilation ne g\'en\`ere pas
d'erreur et qu'il y a un fichier \og README \fg{} pour expliquer l'utilisation
du programme si ce n'est pas \'evident. Dans un deuxi\`eme temps, d'un point de
vu fonctionnel, nous devions v\'erifier si le programme ne pr\'esente pas de
bogue ou de fuite m\'emoire. Enfin, d'un point de vue programmation, nous
devions porter notre attention sur les patrons de conception (ou \textit{design
patterns} en anglais).

\subsection{Les relectures que nous avons r\'ealis\'e}
Nous avons eu \`a faire la relecture des groupes A, D et G. Comme nous sommes
trois, nous nous sommes divis\'e le travail et avons \'evalu\'e un groupe
chacun. Nous nous sommes ensuite concert\'e pour harmoniser nos commentaires.
Cette relecture f\^ut tr\`es int\'eressente car elle nous a permis de mettre au
premier plan les points importants sur lesquels il faut insister lors du
d\'eveloppement d'un projet. En plus de cela, comme chaque groupe à eu le choix
sur la façon d'impl\'ementer son programme, nous avons vu les diff\'erentes
possibilit\'es d'implementation parfois meilleure et plus \'efficace ou pas. Le
but n'\'etait pas d'\^etre trop s\'ev\`ere ou au contraire laxiste sur nos
commentaires car ceux que nous avons donn\'e sur chaque projet n'ont pas \'et\'e
not\'e.
\subsection{Les reslectures r\'ealis\'e par les autres groupes}
\label{notre_etude}
En ce qui concerne les commentaires qui ont \'et\'e faits par les autres groupes
sur notre projet, nous les avons trouv\'e justifi\'e. Mem\^e si, il faut
l'avouer, recevoir des \og critiques \fg{} sur le travail que nous avons
r\'ealis\'e pendant pr\`es de trois ou quatre semaines fait un peu grincer des
dents. Nous avons pris ces critiques en compte et en avons corrig\'e un
maximum avant le rendu final. 
\par Nous avons principalement reçu des commentaires n\'egatifs sur ma
duplication de code dans l'implementation du moteur de jeu. Certaines fonctions
dans utilis\'e dans les fonctions \og can\_move \fg{} et \og do\_move \fg{} se
rensemble fortement. Un autre point \`a \'et\'e remarqu\'e, le nomage des
variables et les commentaires dans le code source \'etaient certaines fois en
français et d'autre en anglais alors que les patrons de conceptions nous
impos\'e de les mettre qu'en anglais.

\newpage
\section{Les strat\'egies}

\newpage
\section{Une vrai interface graphique ?!}

\newpage
\section{En bref}

\newpage
\bibliographystyle{alpha}
\bibliography{biblio}

\newpage
\section{Annexes}
\listoffigures
\begin{figure}
   \caption{\label{grid_h} Debut du fichier grid.h}
   \includegraphics[scale=0.6]{grid_h.png}
\end{figure}

\begin{figure}
   \caption{\label{grille_couleur} Deuxi\`eme version d'affichage de la grille}
   \includegraphics[width=7cm]{grille_couleur.png}
\end{figure}

\begin{figure}
   \caption{\label{test} R\'esultat ex\'ecution des tests}
   \includegraphics[scale=0.6]{test.png}
\end{figure}
\end{document}